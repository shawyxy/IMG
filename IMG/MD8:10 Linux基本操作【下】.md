#  1. more指令

##  语法

```shell
cat [选项] [文件]
```

##  功能

查看目标文件内容

该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比。可以用下列不同的方法对提示做出回答：

- 按 `Space` 键：显示文本的下一屏内容。
- 按 `Enter` 键：只显示文本的下一行内容。
- 按斜线符`|`：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。
- 按H键：显示帮助屏，该屏上有相关的帮助信息。
- 按B键：显示上一屏内容。
- 按Q键：退出more命令。

##  选项

- -<数字>：指定每屏显示的行数； 
- -d：显示“[press space to continue,'q' to quit.]”和“[Press 'h' for instructions]”； 
- -c：不进行滚屏操作。每次刷新这个屏幕； 
- -s：将多个空行压缩成一行显示； 
- -u：禁止下划线； 
- +<数字>：从指定数字的行开始显示；
- -n：对输出的所有行编号。

##  示例

直接查看文件内容

``` shell
more test.txt
```

![image-20220810170523776](https://raw.githubusercontent.com/shawyxy/IMG/main/IMGimage-20220810170523776.png)

指令会将文本内容占满终端窗口，同时在最底部的一行显示进度。按下回车键会往下读取一行，直到进度100%。或直接按下q然后回车，也会停止显示。

除此之外，可能还会搭配选项使用。

显示文件的内容，但在显示之前先清屏，并且在屏幕的最下方显示完成的百分比。

```shell
more -dc test.txt
```

显示文件file的内容，每10行显示一次，而且在显示之前先清屏。

```shell
more -c -10 test.txt
```

然而，more指令其实使用频率不是很高，因为它有点鸡肋。而且有与它类似比它更好的工具。

#  *2. less指令

## 语法

```shell
less [选项] [参数]
```

##  功能

分屏上下翻页浏览文件内容

## 选项

```shell
-e：文件内容显示完毕后，自动退出；
-f：强制显示文件；
-g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度；
-l：搜索时忽略大小写的差异；
-N：每一行行首显示行号；
-s：将连续多个空行压缩成一行显示；
-S：在单行显示较长的内容，而不换行显示；
-x<数字>：将TAB字符显示为指定个数的空格字符。
```

## 示例

显示文本的同时显示行号。

```shell
less -N test.txt
```

![image-20220810172758025](https://raw.githubusercontent.com/shawyxy/IMG/main/IMGimage-20220810172758025.png)

按PageUp（↑）和PageDown（↓）翻页，在文件末尾时会提示如图的（end），按下q+回车退出。

## 补充

**less命令** 的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。

关于对各种文本查看指令的比较：

- cat通常查看短小的文本。nano工具可以查看短小的代码；
- more和less（主要是less）**粗看**较长的文本、代码；
- 其他文本编辑器**细看**文本、代码，因为有高亮。

#  3. head指令

## 语法

```shell
head [选项] [文件]
```

## 功能

显示文件的开头部分。

## 选项

- -n：显示前n行

##  注意

- 在未指定行数时默认显示前10行；
- 处理多个文件时会在各个文件之前附加含有文件名的行；
- 当没有文件或文件为`-`时，读取标准输入。

##  示例

打印文件前30行内容

```shell
head -30 test.txt
```

#  4. tail指令

tail指令和head指令的语法大致相同。

##  语法

```shell
tail [选项] [文件]
```

##  功能

在屏幕上显示指定文件的末尾若干行。

##  选项

- -n：显示后n行

##  注意

- 默认在屏幕上显示指定文件的末尾10行。
- 处理多个文件时会在各个文件之前附加含有文件名的行。
- 如果没有指定文件或者文件名为`-`，则读取标准输入。

##  示例

显示文件末尾30行的内容

```shell
tail -30 test.txt
```

和head指令搭配，显示文件中间20-30行的内容

1. 取出文件的前30行，将它放在临时文件tmp.txt中
2. 然后对临时文件取后30-20+1=11行

```shell
head -30 test.txt > tmp.txt
tail -11 tmp.txt
```

但是这样的方法在文件特别大时有点尴尬。下面介绍一个重要的方法：管道。

```shell
head -30 test.txt | tail -11
```

##  管道

这里的`|`称之为管道。何为管道？在现实生活中，管道是用来传输资源的，例如石油、自来水管道等等。计算机中的管道也是被用来传输资源的，对于计算机，资源就是数据。

也就是说，管道是用来传导数据的，那么它就需要有入口和出口。在这里，head就是入口，tail就是出口。对于这两个指令本身而言，数据本来是要被输出（显示）到显示器上，但是这些数据被汇入管道中，成为管道文件。

> 管道文件是内存级文件，不存在于磁盘上。
>
> 同时提出一个非常重要的思想：Linux下一切皆文件。

管道可以有多个出口，搭配wc指令使用：

> wc指令可以计算文件中的行数。

```shell
head -30 test.txt | tail -10 | wc -l
```

结果：

```shell
11
```

#  5. 时间指令

##  5.1 date

###  语法

```shell
date [选项] [格式]
```

###  功能

按选定格式显示或设置系统时间与日期

###  选项

- -s：根据字符串设置系统时间。

输出的时间格式： 格式设定为一个加号后接数个标记，其中常用的标记列表如下

- %d : 日 (01..31)
- %H : 小时(00..23)
- %m : 月份 (01..12)
- %Y : 完整年份 (0000..9999)
- %F : 相当于 %Y-%m-%d
- %X : 相当于 %H:%M:%S
- %M : 分钟(00..59)
- %S : 秒(00..61)

###  示例

```shell
# 格式化输出：
date +"%Y-%m-%d"
2009-12-07

# 输出昨天日期：
date -d "1 day ago" +"%Y-%m-%d"
2012-11-19

# 2秒后输出：
date -d "2 second" +"%Y-%m-%d %H:%M.%S"
2012-11-20 14:21.31

# 1234567890 秒：
date -d "1970-01-01 1234567890 seconds" +"%Y-%m-%d %H:%M:%S"
# 或者
date -d@1234567890 +"%F %T"
# 输出结果
2009-02-13 23:02:30

# 时间格式转换：
date -d "2009-12-12" +"%Y/%m/%d %H:%M.%S"
# 输出结果
2009/12/12 00:00.00


# 时间加减操作：
date +%Y%m%d                   # 显示年月日
date -d "+1 day" +%Y%m%d       # 显示前一天的日期
date -d "-1 day" +%Y%m%d       # 显示后一天的日期
date -d "-1 month" +%Y%m%d     # 显示上一月的日期
date -d "+1 month" +%Y%m%d     # 显示下一月的日期
date -d "-1 year" +%Y%m%d      # 显示前一年的日期
date -d "+1 year" +%Y%m%d      # 显示下一年的日期

# 设定时间：
date -s                         # 设置当前时间，只有root权限才能设置，其他只能查看
date -s 20120523                # 设置成20120523，这样会把具体时间设置成00:00:00
date -s 01:01:01                # 设置具体时间，不会对日期做更改
date -s "01:01:01 2012-05-23"   # 这样可以设置全部时间
date -s "01:01:01 20120523"     # 这样可以设置全部时间
date -s "2012-05-23 01:01:01"   # 这样可以设置全部时间
date -s "20120523 01:01:01"     # 这样可以设置全部时间
```

####   时间戳

- 时间戳转化为时间：`date +%s`

- 时间转化为为时间戳：`date -d@1508749502`
- unix时间戳是从1970年1月1日开始所经过的秒数（不考虑闰秒）

## 5.2 cal指令

###   语法

```shelll
cal [选项] [月份] [年份]
```

###  功能

**cal命令** 用于显示当前日历，或者指定日期的日历，如果没有指定参数，则显示当前月份。

一个单一的参数指定要显示的年份 (1 - 9999) ; 注意年份必须被完全地指定: cal 89 不会 显示1989年的日历. 两个参数表示月份 (1 - 12) 和年份. 如果没有指定参数, 则显示当前月份的日历.

一年从Jan 1 (1 月 1 日) 开始.

格里高利历法改革(Gregorian Reformation)被认为发生于 1752 年 9 月 3 日. 在此之前, 多数国家已经认可这项改革(尽管有一些直到 20 世纪初才认可它). 那天之后的 10 天在这项改革被略去了, 所以那个月的日历有点不太寻常.

### 选项

- -l # 显示单月输出；
- -3 # 显示临近三个月的日历；
- -s # 将星期日作为月的第一天；
- -m # 显示星期一作为一周的第一天  (缺省为星期日)；
- -j # 显示儒略历的(Julian)日期 (以 1 为基的天数, 从 1 月 1 日开始计数)；
- -y # 显示当前年份的日历。

###   示例

直接cal

```shell
cal
```

打印日历（实际上具体日期会标识的）

```shell
     August 2022    
Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6
 7  8  9 10 11 12 13
14 15 16 17 18 19 20
21 22 23 24 25 26 27
28 29 30 31
```

加上参数

```shell
cal -j
        August 2022        
Sun Mon Tue Wed Thu Fri Sat
    213 214 215 216 217 218
219 220 221 222 223 224 225
226 227 228 229 230 231 232
233 234 235 236 237 238 239
240 241 242 243
```

```shell
cal -3
      July 2022            August 2022         September 2022   
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa
                1  2      1  2  3  4  5  6               1  2  3
 3  4  5  6  7  8  9   7  8  9 10 11 12 13   4  5  6  7  8  9 10
10 11 12 13 14 15 16  14 15 16 17 18 19 20  11 12 13 14 15 16 17
17 18 19 20 21 22 23  21 22 23 24 25 26 27  18 19 20 21 22 23 24
24 25 26 27 28 29 30  28 29 30 31           25 26 27 28 29 30   
31
```

#  **6.find指令

##   语法

```shell
find [选项] [参数]
```

##  功能

**find命令** 用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。

##  选项

- -name 按文件名查找

> 事实上find指令的选项非常多，而且很多也是经常使用的。但是最最常用的莫过于这个，所以初学时主要掌握这个就足够了。

- -amin<分钟>：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；
- -anewer<参考文件或目录>：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；
- -atime<24小时数>：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；
- -cmin<分钟>：查找在指定时间之时被更改过的文件或目录；
- -cnewer<参考文件或目录>查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
- -ctime<24小时数>：查找在指定时间之时被更改的文件或目录，单位以24小时计算；
- -daystart：从本日开始计算时间；
- -depth：从指定目录下最深层的子目录开始查找；
- -empty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；
- -exec<执行指令>：假设find指令的回传值为True，就执行该指令；
- -false：将find指令的回传值皆设为False；
- -fls<列表文件>：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；
- -follow：排除符号连接；
- -fprint<列表文件>：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；
- -fprint0<列表文件>：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；
- -fprintf<列表文件><输出格式>：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；
- -fstype<文件系统类型>：只寻找该文件系统类型下的文件或目录；
- -gid<群组识别码>：查找符合指定之群组识别码的文件或目录；
- -group<群组名称>：查找符合指定之群组名称的文件或目录；
- -help或--help：在线帮助；
- -ilname<范本样式>：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；
- -iname<范本样式>：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；
- -inum<inode编号>：查找符合指定的inode编号的文件或目录；
- -ipath<范本样式>：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；
- -iregex<范本样式>：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；
- -links<连接数目>：查找符合指定的硬连接数目的文件或目录；
- -lname<范本样式>：指定字符串作为寻找符号连接的范本样式；
- -ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；
- -maxdepth<目录层级>：设置最大目录层级；
- -mindepth<目录层级>：设置最小目录层级；
- -mmin<分钟>：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；
- -mount：此参数的效果和指定“-xdev”相同；
- -mtime<24小时数>：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；
- -name<范本样式>：指定字符串作为寻找文件或目录的范本样式；
- -newer<参考文件或目录>：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；
- -nogroup：找出不属于本地主机群组识别码的文件或目录；
- -noleaf：不去考虑目录至少需拥有两个硬连接存在；
- -nouser：找出不属于本地主机用户识别码的文件或目录；
- -ok<执行指令>：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；
- -path<范本样式>：指定字符串作为寻找目录的范本样式；
- -perm<权限数值>：查找符合指定的权限数值的文件或目录；
- -print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“./”字符串；
- -print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；
- -printf<输出格式>：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；
- -prune：不寻找字符串作为寻找文件或目录的范本样式;
- -regex<范本样式>：指定字符串作为寻找文件或目录的范本样式；
- -size<文件大小>：查找符合指定的文件大小的文件；
- -true：将find指令的回传值皆设为True；
- -type<文件类型>：只寻找符合指定的文件类型的文件；
- -uid<用户识别码>：查找符合指定的用户识别码的文件或目录；
- -used<日数>：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；
- -user<拥有者名称>：查找符和指定的拥有者名称的文件或目录；
- -version或——version：显示版本信息；
- -xdev：将范围局限在先行的文件系统中；
- -xtype<文件类型>：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。

##  示例

查找某条路径下的某个文件

```shell
find /home/xy/test test.txt
```

```shell
/home/xy/test
/home/xy/test/test.txt
test.txt
```

列出当前目录及子目录下所有文件和文件夹

```shell
find .
```

在`/home`目录下查找以.txt结尾的文件名

```shell
find /home -name "*.txt"
```

同上，但忽略大小写

```shell
find /home -iname "*.txt"
```

#  7. which指令

##  语法

```shell
which [选项] [指令名]
```

##  功能

**which命令** 用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。

##  选项

- -n<文件名长度>：制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；
- -p<文件名长度>：与-n参数相同，但此处的<文件名长度>包含了文件的路径；
- -w：指定输出时栏位的宽度；
- -V：显示版本信息。

##  示例

查找cd命令路径

```shell
which cd
/usr/bin/cd
```

查找pwd命令路径

```shell
which pwd
/usr/bin/pwd
```

查找ls命令路径

```shell
which ls
alias ls='ls --color=auto'
        /usr/bin/ls
```

我们知道ls命令是ll -s的简写，但查它的路径时怎么会有个alias呢？原来，alias是给指令起别名，``alias 别名='指令'``。这是Linux自带的，也许是维护的大佬设置的。

#   8. whereis指令

##   语法

```shell
whereis [选项] [指令名]
```

##   功能

**whereis命令** 用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。

whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。

和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。

##   选项

- -b：只查找二进制文件；
- -B<目录>：只在设置的目录下查找二进制文件；
- -f：不显示文件名前的路径名称；
- -m：只查找说明文件；
- -M<目录>：只在设置的目录下查找说明文件；
- -s：只查找原始代码文件；
- -S<目录>只在设置的目录下查找原始代码文件；
- -u：查找不包含指定类型的文件。

##  示例

查找ls指令

```shell
whereis ls
ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz
```

#  9. grep指令

##  语法

``` shell
grep [选项] [字符串/关键字] [文件]
```

##  功能

**grep** （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能配合多种命令使用，使用上十分灵活。

简单地说，它就是一个行文本过滤器。

##  选项

- -i：忽略大小写
- -n：输出行好
- -v：反向查找

##  示例

查看文件中有5的每行。关键字加不加双引号都可以。

```shell
grep 5 file.txt
```

![image-20220810194637275](https://raw.githubusercontent.com/shawyxy/IMG/main/IMGimage-20220810194637275.png)

查找并在管道中查看内容

```shell
grep "5" file.txt | cat
```

![image-20220810194700491](https://raw.githubusercontent.com/shawyxy/IMG/main/IMGimage-20220810194700491.png)

当然也可以用tac反向显示行内容。

也可以写入到文件中

```shell
grep "5" file.txt | tac | head -3 > tmp.txt
cat tmp.txt
```

```shell
 35 hello world
 25 hello world
 15 hello world
```

有点炫酷。

对搜索到的行内容显示行号。

```shell
grep -n "5" file.txt
```

![image-20220810195201933](https://raw.githubusercontent.com/shawyxy/IMG/main/IMGimage-20220810195201933.png)

#  10. zip/unzip指令

##  语法

```shell
zip/unzip [选项] [被压缩文件/.zip文件]
```

##  功能

-  zip：将文件打包压缩
- unzip：将文件解压缩

##  选项

- -r：递归处理，将指定目录下的所有文件和子目录一并处理。

##  示例

将目录压缩

```shell
zip test.zip test/*
```

解压到指定目录tmp

``` shell
unzip test.zip -d /tmp
```

#  *11. tar指令

##   语法

```shell
tar [选项] [文件]
```

##   功能

将许多文件一起保存至一个单独的磁带或磁盘归档，并能从归档中单独还原所需文件。

**tar命令**（tarfile） 可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。

首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。

为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。

##  选项

- -c：建立一个压缩文件；
- -x：解开一个压文件；
- -t：查看包内的文件；
- -z：是否具有gzip属性；
- -j：是否句有bzip2属性；
- -v：压缩过程中显示文件，不建议在背景执行过程；
- -f：使用档名，直接加档名；
- -C：解压到指定目录。

##   示例

将 `/home/vivek/bin/` 目录打包，并使用 gzip 算法压缩。保存为 `/tmp/bin-backup.tar.gz` 文件。

```
tar -zcvf /tmp/bin-backup.tar.gz /home/vivek/bin/
- z：有gzip属性的
- j：有bz2属性的
- Z：有compress属性的
- v：显示所有过程
- O：将文件解开到标准输出

tar -cf archive.tar foo bar  # 从文件 foo 和 bar 创建归档文件 archive.tar。
tar -tvf archive.tar         # 详细列举归档文件 archive.tar 中的所有文件。
tar -xf archive.tar          # 展开归档文件 archive.tar 中的所有文件。
```

#### zip格式

压缩： zip -r [目标文件名].zip [原文件/目录名]
解压： unzip [原文件名].zip
注：-r参数代表递归

#### tar格式（该格式仅仅打包，不压缩）

打包：tar -cvf [目标文件名].tar [原文件名/目录名]
解包：tar -xvf [原文件名].tar
注：c参数代表create（创建），x参数代表extract（解包），v参数代表verbose（详细信息），f参数代表filename（文件名），所以f后必须接文件名。

#### 最常用

```shell
压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称
查　询：tar -jtv -f filename.tar.bz2
解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录
```

其中诸如`-jcv -f`可以写成`-jcvf`

#  12. 热键

- 「tab」：命令补全，档案补齐

  例如当前目录下只有一个目录或文件，按下tab键自动补齐命令

  ```shell
  cd+tab
  ↓
  cd linux/
  ```

  如果有很多个目录或文件，如：abc.txt,bc.txt,b.txt三个文件

  ```shell
  打开abc.txt
  cd a+tab
  ↓
  cd abc.txt
  ```

  ```shell
  打开bc.txt
  cd b+tab
  ```

  由于有两个文件是b开头的，按下tab键后会罗列出以b开头的文件，所以要输到不同子母的位置再按tab才会自动补齐，以此类推。

- 「ctrl」+ c：有时候命令按错但不想重新改，有时输入命令很久都没有运行完毕，这时候可以键入它以终止指令和终止当前程序运行。
- 「ctrl」+ d：键入结束或表示exit。

#   13. 关机

##  语法

```shell
shutdown [选项]
```

##  选项

- -h：将系统的服务停止后关机；
- r：将系统的服务停止后重启；
- -t sec：-t后面加秒数，表示xx秒后关机。

#  14. 补充命令

安装和登录命令:login、shutdown、halt、reboot、install、mount、umount、chsh、exit、last;

文件处理命令:file、mkdir、grep、dd、find、mv、ls、diff、cat、ln;系统管理相关命令:df、top、free、quota、at、lp、adduser、groupadd、kill、crontab;
系统安全相关命令:passwd、su、umask、chgrp、chmod、chown、chattr、sudo ps、who;
网络操作命令:ifconfig、ip、ping、netstat、telnet、ftp、route、rlogin、rcp、finger、mail、 nslookup; 

其它命令:gunzip、unarj、mtools、man、unendcode、uudecode。

a

# **15. 权限

Linux下拥有最高权限的是root用户。除了它之外，还可以有其他用户。所以Linux下有两种用户：超级用户（root）和普通用户。

- 超级用户：不受限制地做任何事情；
- 普通用户：受限制地做部分事情；

注意：超级用户的命令提示符是`#` ，普通用户是`$`。

##   su指令

###  语法

```shell
su [用户名]
```

##  功能

切换用户。

如果从普通用户切换到超级用户，用户名可省略不用加root。

```shell
su
```

##  权限

###  访问者

- 文件或目录所有者：u（user）；
- 文件或目录所有者所在组的用户：g（group）；
- 其他用户：o（other）

> 用一个例子理解：user代表宪法，group代表government（中文自己查），o代表外国人。

###  文件类型和访问权限

用ll显示文件的详细信息。

```shell
drwxrwxr-x 4 xy xy 4096 Aug  9 21:58 Code
-rw-rw-r-- 1 xy xy   70 Aug  9 23:04 test1.txt
```

![image-20220811002458031](https://raw.githubusercontent.com/shawyxy/IMG/main/IMGimage-20220811002458031.png)
